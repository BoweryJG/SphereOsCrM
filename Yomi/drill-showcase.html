<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            cursor: none;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #blackScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }

        .drill-selection {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 40px;
            z-index: 100;
            opacity: 0;
            transition: opacity 1s ease-in;
        }

        .drill-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            color: white;
            text-align: center;
            min-width: 120px;
        }

        .drill-option:hover {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 255, 136, 0.3);
        }

        .drill-option.selected {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.3);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.5);
        }

        .drill-name {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .drill-type {
            font-size: 11px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="blackScreen"></div>
    <canvas id="canvas"></canvas>
    
    <div class="drill-selection">
        <div class="drill-option" data-drill="freehand">
            <div class="drill-name">FREEHAND</div>
            <div class="drill-type">7mm variance | 7° angular</div>
        </div>
        <div class="drill-option" data-drill="static">
            <div class="drill-name">STATIC GUIDE</div>
            <div class="drill-type">3.5mm variance | 3° angular</div>
        </div>
        <div class="drill-option" data-drill="yomi">
            <div class="drill-name">YOMI ROBOTIC</div>
            <div class="drill-type">&lt;0.2mm variance | &lt;1.5° angular</div>
        </div>
    </div>

    <!-- Dr. Neugarten Study Credit -->
    <div style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 11px; line-height: 1.5; letter-spacing: 0.5px; font-weight: 300; z-index: 100;">
        Clinical precision data from peer-reviewed research by<br>
        <span style="color: rgba(0, 255, 136, 0.8); font-weight: 400;">Dr. Jay Neugarten</span> | International Journal of Oral & Maxillofacial Implants
    </div>

    <audio id="bgMusic" loop>
        <source src="https://www.soundjay.com/misc/sounds/bell-ringing-05.wav" type="audio/wav">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBkKX2+29dykGNIzQ8N2QQAoUY7Lp66hVFApGnt/yvmUCBUOY2+2+dykGN4nP8N6PQAoUYbLp66pVFAlJnt7xv2UDBkGY2uy+dygKNYnN8N6PQAcUYbLp66pVFAlFnt7xwmUCBECY2uy+dygHNYnN8N6PQAcUYrLo66pVFAlFnt7ww2UDBECy2uy+dygHNIjO8N+PQAcUYrLo66tVFAlEnt7ww2UDBECy2uy+dygHNIjO8N+PQAcTYrLo66tVFAlEnt7ww2UDBECy2uy+dygHNIjO8N+PQAcTYrLo66tVFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBECy2uy+eCADN4nO8N6PQAcTYrLo66tWFAlEnt7ww2UDBEAAAAAA=" type="audio/wav">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Variables
        let drills = [];
        let selectedDrill = null;
        let mouseX = 0, mouseY = 0;
        let isWielding = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Audio
        const bgMusic = document.getElementById('bgMusic');
        
        // DR. NEUGARTEN'S EXACT CLINICAL DATA - Published measurements
        const methodData = {
            freehand: {
                color: 0xff4444,
                variance: 0.7,          // 7mm variance - VERY DIFFICULT
                angularError: 7,        // 7° angular deviation
                shake: 0.08,            // Major hand tremor - realistic difficulty
                drift: 0.05,            // Significant natural hand drift
                description: 'Freehand Surgery'
            },
            static: {
                color: 0xffaa00,
                variance: 0.35,         // 3.5mm variance - MODERATE difficulty
                angularError: 3,        // 3° angular deviation
                shake: 0.03,            // Moderate shake even with guide
                drift: 0.02,            // Some drift still present
                description: 'Static Guided'
            },
            yomi: {
                color: 0x00ff88,
                variance: 0.002,        // <0.2mm variance - EASY with robot
                angularError: 1.5,      // <1.5° angular deviation
                shake: 0.0001,          // Virtually no shake
                drift: 0,               // Zero drift with robotic guidance
                description: 'Yomi Robotic'
            }
        };

        // Create realistic drill with pathway cone
        function createRealisticDrill(method) {
            const data = methodData[method];
            const drillGroup = new THREE.Group();
            
            // Drill body - realistic cylindrical shape
            const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.1, 3, 16);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({
                color: data.color,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1,
                clearcoatRoughness: 0,
                emissive: data.color,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            drillGroup.add(body);
            
            // Drill tip - sharp cone
            const tipGeometry = new THREE.ConeGeometry(0.1, 0.5, 8);
            const tip = new THREE.Mesh(tipGeometry, bodyMaterial);
            tip.position.y = -1.75;
            drillGroup.add(tip);
            
            // Surgical pathway cone showing precision variance
            const topRadius = 0.01;
            const height = 5;
            const angleRad = (data.angularError * Math.PI) / 180;
            const bottomRadius = Math.tan(angleRad) * height + data.variance;
            
            const coneGeometry = new THREE.CylinderGeometry(topRadius, bottomRadius, height, 32, 1, true);
            const coneMaterial = new THREE.MeshBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const pathwayCone = new THREE.Mesh(coneGeometry, coneMaterial);
            pathwayCone.position.y = -2 - height/2;
            drillGroup.add(pathwayCone);
            
            // Wireframe for pathway visibility
            const wireframeGeometry = new THREE.CylinderGeometry(topRadius, bottomRadius, height, 16, 1, true);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: data.color,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            wireframe.position.y = -2 - height/2;
            drillGroup.add(wireframe);
            
            drillGroup.userData = { 
                type: method, 
                originalColor: data.color,
                wobbleOffset: Math.random() * Math.PI * 2,
                methodData: data
            };
            
            return drillGroup;
        }

        // Create three realistic drills
        function createDrills() {
            const types = ['freehand', 'static', 'yomi'];
            const positions = [
                new THREE.Vector3(-4, 2, 0),
                new THREE.Vector3(0, 2, 0),
                new THREE.Vector3(4, 2, 0)
            ];

            types.forEach((type, i) => {
                const drill = createRealisticDrill(type);
                drill.position.copy(positions[i]);
                drill.scale.setScalar(0);
                scene.add(drill);
                drills.push(drill);
            });
        }

        // Lighting
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Dramatic side lighting
            const sideLight1 = new THREE.SpotLight(0x00ff88, 0.8);
            sideLight1.position.set(-10, 5, 0);
            sideLight1.angle = Math.PI / 4;
            scene.add(sideLight1);

            const sideLight2 = new THREE.SpotLight(0xff4444, 0.8);
            sideLight2.position.set(10, 5, 0);
            sideLight2.angle = Math.PI / 4;
            scene.add(sideLight2);
        }

        // Animation functions
        function animateDrillEntry() {
            drills.forEach((drill, index) => {
                setTimeout(() => {
                    // Scale up with bounce
                    const tl = gsap.timeline();
                    tl.to(drill.scale, {
                        x: 1, y: 1, z: 1,
                        duration: 1.5,
                        ease: "back.out(1.7)"
                    });
                    
                    // Add spinning entrance
                    tl.to(drill.rotation, {
                        y: Math.PI * 2,
                        duration: 2,
                        ease: "power2.out"
                    }, 0);

                    // Add sound effect
                    playSound(440 + index * 110, 0.3, 'sine');
                }, index * 300);
            });
        }

        function wieldDrill(drill) {
            if (!drill || !isWielding) return;

            const data = drill.userData.methodData;
            const targetX = (mouseX / window.innerWidth) * 8 - 4;
            const targetY = -(mouseY / window.innerHeight) * 6 + 3;

            // Smooth following with method-specific responsiveness
            const responsiveness = drill.userData.type === 'yomi' ? 0.15 : 
                                 drill.userData.type === 'static' ? 0.08 : 0.05;

            drill.position.x += (targetX - drill.position.x) * responsiveness;
            drill.position.y += (targetY - drill.position.y) * responsiveness;
            
            // Add realistic surgical tremor/wobble
            const time = Date.now() * 0.001;
            drill.rotation.x = Math.sin(time * 2) * data.shake * 3;
            drill.rotation.z = Math.cos(time * 1.5) * data.shake * 3;
            
            // Continuous rotation for cutting effect
            drill.rotation.y += 0.1;
            
            // Yomi gets special precision glow
            if (drill.userData.type === 'yomi' && drill.children[0]) {
                const emissiveIntensity = 0.2 + Math.sin(time * 4) * 0.1;
                drill.children[0].material.emissiveIntensity = emissiveIntensity;
            }
        }

        // Event listeners
        document.addEventListener('mousemove', (event) => {
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(drills, true);

            if (intersects.length > 0) {
                const clickedDrill = intersects[0].object.parent;
                selectDrill(clickedDrill);
            }
        });

        document.querySelectorAll('.drill-option').forEach(option => {
            option.addEventListener('click', () => {
                const drillType = option.dataset.drill;
                const drill = drills.find(d => d.userData.type === drillType);
                if (drill) selectDrill(drill);
            });
        });

        function selectDrill(drill) {
            // Reset previous selection
            if (selectedDrill) {
                // Reset pathway cone opacity
                if (selectedDrill.children[2]) {
                    selectedDrill.children[2].material.opacity = 0.2;
                }
                if (selectedDrill.children[3]) {
                    selectedDrill.children[3].material.opacity = 0.4;
                }
                isWielding = false;
            }

            selectedDrill = drill;
            
            // Highlight selected drill's pathway
            if (drill.children[2]) {
                drill.children[2].material.opacity = 0.5;
            }
            if (drill.children[3]) {
                drill.children[3].material.opacity = 0.8;
            }
            
            isWielding = true;

            // Update UI
            document.querySelectorAll('.drill-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector(`[data-drill="${drill.userData.type}"]`).classList.add('selected');

            // Play method-specific selection sound
            const frequency = drill.userData.type === 'yomi' ? 660 : 
                            drill.userData.type === 'static' ? 550 : 440;
            playSound(frequency, 0.15, 'sine');
            
            // Add haptic feedback if available
            if (navigator.vibrate) {
                const pattern = drill.userData.type === 'yomi' ? [50] : 
                              drill.userData.type === 'static' ? [100] : [200];
                navigator.vibrate(pattern);
            }
        }

        function playSound(frequency, duration, type = 'sine') {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Main animation loop with surgical precision simulation
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // Animate non-selected drills with method-specific behaviors
            drills.forEach(drill => {
                if (drill !== selectedDrill) {
                    const data = drill.userData.methodData;
                    const wobbleOffset = drill.userData.wobbleOffset;
                    
                    // Apply method-specific wobble and drift
                    drill.rotation.x = Math.sin(time * 2 + wobbleOffset) * data.shake * 3;
                    drill.rotation.z = Math.cos(time * 1.5 + wobbleOffset) * data.shake * 3;
                    drill.position.y = 2 + Math.sin(time * 3 + wobbleOffset) * data.drift * 5;
                    
                    // Slow rotation
                    drill.rotation.y += 0.01;
                    
                    // Yomi gets special glow
                    if (drill.userData.type === 'yomi' && drill.children[0]) {
                        const emissiveIntensity = 0.2 + Math.sin(time * 4) * 0.1;
                        drill.children[0].material.emissiveIntensity = emissiveIntensity;
                    }
                }
            });

            // Wield selected drill with surgical precision
            wieldDrill(selectedDrill);

            renderer.render(scene, camera);
        }

        // Initialization sequence
        function init() {
            camera.position.z = 10;
            setupLighting();
            createDrills();

            // 5-second black screen
            setTimeout(() => {
                document.getElementById('blackScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('blackScreen').style.display = 'none';
                    animateDrillEntry();
                    document.querySelector('.drill-selection').style.opacity = '1';
                }, 1000);
            }, 5000);

            // Start music at 3 seconds
            setTimeout(() => {
                bgMusic.play().catch(console.log);
            }, 3000);

            animate();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start the experience
        init();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</body>
</html>